Re: 0.00000000000000000000000
Im: 0.00000000000000000000000
Zoom: 1.0000000000000000E0
Iterations: 3004
IterDiv: 0.0100000000000000002
SmoothMethod: 0
SmoothingMethod: 0
BailoutRadiusPreset: 0
BailoutRadiusCustom: 2
BailoutNormPreset: 1
BailoutNormCustom: 2
ColorMethod: 7
Differences: 3
ColorOffset: 0
ColorPhaseStrength: 0
Colors: 255,255,255,128,0,64,160,0,0,192,128,0,64,128,0,0,255,255,64,128,255,0,0,255,
InteriorColor: 0,0,0,
Smooth: 1
Flat: 0
MultiColor: 0
BlendMC: 0
MultiColors: 
Power: 2
FractalType: 0
Slopes: 1
SlopePower: 50
SlopeRatio: 20
SlopeAngle: 45
real: 1
imag: 1
SeedR: 0
SeedI: 0
FactorAR: 1
FactorAI: 0
Period: 0
TextureEnabled: 0
TextureMerge: 1
TexturePower: 200
TextureRatio: 100
TextureFile: 
RotateAngle: 0
StretchAngle: 0
StretchAmount: 0
UseOpenGL: 1
GLSL: #if\ 1\nconst\ float\ ZoomOffset\ =\ 6.5;\nconst\ vec3\ TextBorder\ =\ vec3(1.0);\nconst\ float\ TextBorderWidth\ =\ 0.1;\nconst\ vec3\ TextColour\ =\ vec3(0.0);\nconst\ int\ Decimals\ =\ 3;\nconst\ float\ HorizontalAlign\ =\ 1;\nconst\ float\ GlyphScale\ =\ 1.5;\nconst\ float\ StrokeLength\ =\ 0.7;\nconst\ float\ StrokeWidth\ =\ 0.2;\n#else\nuniform\ float\ ZoomOffset;\ //\ slider[0,6.5,16]\nuniform\ vec3\ TextBorder;\ //\ color[1,1,1]\nuniform\ float\ TextBorderWidth;\ //\ slider[0,0.1,2]\nuniform\ vec3\ TextColour;\ //\ color[0,0,0]\nuniform\ int\ Decimals;\ //\ slider[0,3,10]\nuniform\ float\ HorizontalAlign;\ //\ slider[0,1,1]\nuniform\ float\ GlyphScale;\ //\ slider[0,1.5,2]\nuniform\ float\ StrokeLength;\ //\ slider[0,0.7,1]\nuniform\ float\ StrokeWidth;\ //\ slider[0,0.2,1]\n#endif\n\n//\ format\ and\ display\ numbers\ in\ scientific\ notation\n\n#define\ DIGIT_NONE\ -1\n//\ digits\ are\ 0..9\n#define\ DIGIT_TIMES\ 10\n#define\ DIGIT_POWER\ 11\n#define\ DIGIT_MINUS\ 12\n#define\ DIGIT_POINT\ 13\n\n#define\ DECIMALS_MAX\ 7\n#define\ EXPONENT_MAX\ 10\n#define\ SCIENTIFIC_MAX\ (3\ +\ DECIMALS_MAX\ +\ 5\ +\ EXPONENT_MAX)\n\n//\ format\ to\ scientific,\ with\ log-domain\ input\ (useful\ for\ representing\ very\ big/small\ values)\n\nint[SCIENTIFIC_MAX]\ formatScientificLog2(int\ sign_of_number,\ float\ number_log2,\ int\ decimals)\n{\n\ \ //\ output\ string\n\ \ int[SCIENTIFIC_MAX]\ string;\n\ \ for\ (int\ i\ =\ 0;\ i\ <\ SCIENTIFIC_MAX;\ ++i)\n\ \ {\n\ \ \ \ string[i]\ =\ DIGIT_NONE;\n\ \ }\n\ \ int\ cursor\ =\ 0;\n\n\ \ //\ handle\ 0\n\ \ if\ (sign_of_number\ ==\ 0)\n\ \ {\n\ \ \ \ string[cursor++]\ =\ 0;\n\ \ \ \ return\ string;\n\ \ }\n\n\ \ //\ handle\ special\ values\n\ \ if\ (isnan(number_log2)\ ||\ isinf(number_log2))\n\ \ {\n\ \ \ \ string[cursor++]\ =\ DIGIT_TIMES;\n\ \ \ \ string[cursor++]\ =\ DIGIT_TIMES;\n\ \ \ \ string[cursor++]\ =\ DIGIT_TIMES;\n\ \ \ \ return\ string;\n\ \ }\n\n\ \ //\ handle\ negative\ number\n\ \ if\ (sign_of_number\ <\ 0)\n\ \ {\n\ \ \ \ string[cursor++]\ =\ DIGIT_MINUS;\n\ \ }\n\n\ \ //\ split\ log-domain\ scientific\ to\ decimal\ mantissa\ and\ exponent\n\ \ decimals\ =\ clamp(decimals,\ 0,\ DECIMALS_MAX);\n\ \ float\ number_log10\ =\ number_log2\ *\ log(2.0)\ /\ log(10.0);\n\ \ float\ mantissa\ =\ pow(10.0,\ number_log10\ -\ floor(number_log10));\ //\ [1..10)\n\ \ int\ exponent\ =\ int(floor(number_log10));\n\n\ \ //\ get\ decimal\ digits\ of\ mantissa\n\ \ float\ number\ =\ mantissa\ *\ pow(10.0,\ float(decimals));\n\ \ for\ (int\ d\ =\ decimals;\ d\ >=\ 0;\ --d)\n\ \ {\n\ \ \ \ string[cursor\ +\ d\ +\ (d\ >\ 0\ ?\ 1\ :\ 0)]\ =\ int(floor(mod(number,\ 10.0)));\n\ \ \ \ number\ /=\ 10.0;\n\ \ }\n\ \ if\ (decimals\ >\ 0)\n\ \ {\n\ \ \ \ string[cursor\ +\ 1]\ =\ DIGIT_POINT;\n\ \ \ \ cursor++;\n\ \ }\n\ \ cursor\ +=\ decimals\ +\ 1;\n\n\ \ //\ check\ for\ special\ exponents\n\ \ if\ (exponent\ ==\ 0)\n\ \ {\n\ \ \ \ return\ string;\n\ \ }\n\ \ string[cursor++]\ =\ DIGIT_TIMES;\n\ \ string[cursor++]\ =\ 1;\n\ \ string[cursor++]\ =\ 0;\n\ \ if\ (exponent\ ==\ 1)\n\ \ {\n\ \ \ \ return\ string;\n\ \ }\n\ \ string[cursor++]\ =\ DIGIT_POWER;\n\ \ if\ (exponent\ <\ 0)\n\ \ {\n\ \ \ \ string[cursor++]\ =\ DIGIT_MINUS;\n\ \ \ \ exponent\ =\ -exponent;\n\ \ \ \ if\ (exponent\ <\ 0)\n\ \ \ \ {\n\ \ \ \ \ \ //\ INT_MIN,\ gracefully\ underflow...\n\ \ \ \ \ \ for\ (int\ i\ =\ 0;\ i\ <\ SCIENTIFIC_MAX;\ ++i)\n\ \ \ \ \ \ {\n\ \ \ \ \ \ \ \ string[i]\ =\ DIGIT_NONE;\n\ \ \ \ \ \ }\n\ \ \ \ \ \ string[0]\ =\ 0;\n\ \ \ \ \ \ return\ string;\n\ \ \ \ }\n\ \ }\n\n\ \ //\ get\ decimal\ digits\ of\ exponent\n\ \ int[10]\ edigits;\ //\ int\ is\ 32bit\ signed,\ so\ 10\ digits\ is\ enough\n\ \ int\ enumber\ =\ exponent;\n\ \ for\ (int\ d\ =\ 9;\ d\ >=\ 0;\ --d)\n\ \ {\n\ \ \ \ edigits[d]\ =\ enumber\ %\ 10;\n\ \ \ \ enumber\ /=\ 10;\n\ \ }\n\n\ \ //\ copy\ to\ output,\ dropping\ leading\ zeros\n\ \ bool\ copying\ =\ false;\n\ \ for\ (int\ d\ =\ 0;\ d\ <\ 10;\ ++d)\n\ \ {\n\ \ \ \ if\ (edigits[d]\ !=\ 0)\n\ \ \ \ {\n\ \ \ \ \ \ copying\ =\ true;\n\ \ \ \ }\n\ \ \ \ if\ (copying)\n\ \ \ \ {\n\ \ \ \ \ \ string[cursor++]\ =\ edigits[d];\n\ \ \ \ }\n\ \ }\n\ \ if\ (!\ copying)\n\ \ {\n\ \ \ \ //\ should\ never\ happen,\ implies\ exponent\ was\ 0\n\ \ \ \ string[cursor++]\ =\ 0;\n\ \ }\n\n\ \ //\ done!\n\ \ return\ string;\n}\n\n//\ format\ a\ float\ as-is\n\nint[SCIENTIFIC_MAX]\ formatScientific(float\ number,\ int\ decimals)\n{\n\ \ if\ (number\ ==\ 0)\n\ \ {\n\ \ \ \ return\ formatScientificLog2(0,\ 0.0,\ decimals);\n\ \ }\n\ \ else\n\ \ {\n\ \ \ \ return\ formatScientificLog2(number\ >\ 0\ ?\ 1\ :\ -1,\ log2(abs(number)),\ decimals);\n\ \ }\n}\n\n//\ https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat\ sdOrientedBox(\ in\ vec2\ p,\ in\ vec2\ a,\ in\ vec2\ b,\ float\ th\ )\n{\n\ \ \ \ float\ l\ =\ length(b-a);\n\ \ \ \ vec2\ \ d\ =\ (b-a)/l;\n\ \ \ \ vec2\ \ q\ =\ (p-(a+b)*0.5);\n\ \ \ \ \ \ \ \ \ \ q\ =\ mat2(d.x,-d.y,d.y,d.x)*q;\n\ \ \ \ \ \ \ \ \ \ q\ =\ abs(q)-vec2(l,th)*0.5;\n\ \ \ \ return\ length(max(q,0.0))\ +\ min(max(q.x,q.y),0.0);\n}\n\n//\ enhancement\ ideas:\ line\ cap\ styles,\ dashing\ patterns,\ etc...\nfloat\ sdStroke(vec2\ p,\ vec2\ a,\ vec2\ b,\ float\ strokeLength,\ float\ strokeWidth)\n{\n\ \ float\ l\ =\ (1.0\ -\ strokeLength)\ /\ 2.0;\n\ \ vec2\ ab\ =\ mix(a,\ b,\ l);\n\ \ vec2\ ba\ =\ mix(b,\ a,\ l);\n\ \ return\ sdOrientedBox(p,\ ab,\ ba,\ strokeWidth);\n}\n\n//\ display\ a\ digit\ (or\ other\ special\ character)\ in\ calculator\ style\n\nfloat\ sdDigit(vec2\ p,\ int\ digit,\ float\ strokeLength,\ float\ strokeWidth)\n{\n\ \ float\ dist\ =\ 1.0\ /\ 0.0;\n\ \ if\ (digit\ ==\ DIGIT_POINT)\n\ \ {\n\ \ \ \ dist\ =\ min(dist,\ length(p\ -\ vec2(0.0,\ -1.0))\ -\ strokeWidth);\n\ \ \ \ return\ dist;\n\ \ }\n\ \ if\ (digit\ ==\ DIGIT_TIMES)\n\ \ {\n\ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ \ 0.5),\ vec2(0.0,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(\ 0.5,\ \ 0.5),\ vec2(0.0,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ -0.5),\ vec2(0.0,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(\ 0.5,\ -0.5),\ vec2(0.0,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ return\ dist;\n\ \ }\n\ \ if\ (digit\ ==\ DIGIT_POWER)\n\ \ {\n\ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ 0.0),\ vec2(0.0,\ 0.5),\ strokeLength,\ strokeWidth));\n\ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(\ 0.5,\ 0.0),\ vec2(0.0,\ 0.5),\ strokeLength,\ strokeWidth));\n\ \ \ \ return\ dist;\n\ \ }\n\ \ if\ (digit\ ==\ DIGIT_MINUS)\n\ \ {\n\ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ 0.0),\ vec2(0.5,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ return\ dist;\n\ \ }\n\ \ if\ (0\ <=\ digit\ &&\ digit\ <\ 10)\n\ \ {\n\ \ \ \ //\ top\n\ \ \ \ if\ (digit\ !=\ 1\ &&\ digit\ !=\ 4)\n\ \ \ \ {\n\ \ \ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ 1.0),\ vec2(0.5,\ 1.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ }\n\ \ \ \ //\ top\ left\n\ \ \ \ if\ (digit\ !=\ 1\ &&\ digit\ !=\ 2\ &&\ digit\ !=\ 3)\n\ \ \ \ {\n\ \ \ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ 1.0),\ vec2(-0.5,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ }\n\ \ \ \ //\ top\ right\n\ \ \ \ if\ (digit\ !=\ 5\ &&\ digit\ !=\ 6)\n\ \ \ \ {\n\ \ \ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(0.5,\ 1.0),\ vec2(0.5,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ }\n\ \ \ \ //\ middle\n\ \ \ \ if\ (digit\ !=\ 0\ &&\ digit\ !=\ 1\ &&\ digit\ !=\ 7)\n\ \ \ \ {\n\ \ \ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ 0.0),\ vec2(0.5,\ 0.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ }\n\ \ \ \ //\ bottom\ left\n\ \ \ \ if\ (digit\ ==\ 0\ ||\ digit\ ==\ 2\ ||\ digit\ ==\ 6\ ||\ digit\ ==\ 8)\n\ \ \ \ {\n\ \ \ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ 0.0),\ vec2(-0.5,\ -1.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ }\n\ \ \ \ //\ bottom\ right\n\ \ \ \ if\ (digit\ !=\ 2)\n\ \ \ \ {\n\ \ \ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(0.5,\ 0.0),\ vec2(0.5,\ -1.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ }\n\ \ \ \ //\ bottom\n\ \ \ \ if\ (digit\ !=\ 1\ &&\ digit\ !=\ 4\ &&\ digit\ !=\ 7)\n\ \ \ \ {\n\ \ \ \ \ \ dist\ =\ min(dist,\ sdStroke(p,\ vec2(-0.5,\ -1.0),\ vec2(0.5,\ -1.0),\ strokeLength,\ strokeWidth));\n\ \ \ \ }\n\ \ }\n\ \ return\ dist;\n}\n\nfloat\ sdDigits(vec2\ p,\ int[SCIENTIFIC_MAX]\ digits,\ float\ halign,\ float\ strokeLength,\ float\ strokeWidth,\ float\ glyphScale)\n{\n\ \ //\ compute\ translation\ for\ alignment\n\ \ int\ strlen\ =\ SCIENTIFIC_MAX;\n\ \ for\ (int\ i\ =\ 0;\ i\ <\ SCIENTIFIC_MAX;\ ++i)\n\ \ {\n\ \ \ \ if\ (digits[i]\ ==\ DIGIT_NONE)\n\ \ \ \ {\n\ \ \ \ \ \ strlen\ =\ i;\n\ \ \ \ \ \ break;\n\ \ \ \ }\n\ \ }\n\ \ p.x\ =\ mix(p.x,\ p.x\ +\ float(strlen),\ halign);\n\n\ \ //\ draw\ digit\n\ \ float\ dist\ =\ 1.0\ /\ 0.0;\n\ \ int\ ix\ =\ int(floor(p.x));\n\ \ if\ (0\ <=\ ix\ &&\ ix\ <\ strlen\ &&\ -1.0\ <=\ p.y\ &&\ p.y\ <=\ 1.0)\n\ \ {\n\ \ \ \ //\ draw\ digit\ using\ local\ coordinates\n\ \ \ \ int\ digit\ =\ digits[ix];\n\ \ \ \ vec2\ uv\ =\ vec2(p.x\ -\ floor(p.x)\ -\ 0.5,\ p.y);\n\ \ \ \ dist\ =\ min(dist,\ sdDigit(uv\ *\ glyphScale,\ digit,\ strokeLength,\ strokeWidth)\ /\ glyphScale);\n\ \ }\n\ \ return\ dist;\n}\n\nvec3\ colour(void)\n{\n\ \ //\ background\ colour\n\ \ vec3\ RGB\ =\ KF_Colour();\n\ \ \n\ \ //\ position\ near\ the\ top\ right\ of\ 16:9\ frame\n\ \ vec2\ p\ =\ ((getCoord()\ /\ vec2(ImageSize))\ *\ vec2(16.0,\ 16.0)\ +\ vec2(-16.0,\ -15.0))\ *\ 2.0;\n\ \ vec2\ dx\ =\ vec2(1.0\ /\ ImageSize.x\ *\ \ 16.0\ *\ 2.0,\ 0.0);\n\ \ vec2\ dy\ =\ vec2(0.0,\ 1.0\ /\ ImageSize.y\ *\ 16.0\ *\ 2.0);\n\ \ float\ value\ =\ getZoomLog2();\n\n\ \ //\ draw\ number\ distance\ field\n\ \ float\ dist\ =\ 1.0/0.0;\n\ \ dist\ =\ min(dist,\ sdDigits(p\ -\ vec2(0.0,\ 1.0),\ formatScientificLog2(1,\ value,\ Decimals),\ HorizontalAlign,\ StrokeLength,\ StrokeWidth,\ GlyphScale));\n\n\ \ //\ draw\ text\n\ \ float\ aaWidth\ =\ length(vec4(dx,\ dy));\n\ \ float\ border\ =\ smoothstep(0.0\ -\ aaWidth,\ 0.0\ +\ aaWidth,\ TextBorderWidth\ -\ dist);\n\ \ float\ fill\ =\ smoothstep(0.0\ -\ aaWidth,\ 0.0\ +\ aaWidth,\ -dist);\n\ \ return\ mix(mix(RGB,\ TextBorder,\ border),\ TextColour,\ fill);\n}\n
UseSRGB: 0
Version: 2150200
